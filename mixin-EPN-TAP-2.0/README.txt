NOTE that epntap2.xml should be renamed to epntap2.rd
(i've named it .xml only so that GitHub highlights it correctly)

this file (epntap2.rd) should probably be placed into 
/usr/share/pyshared/gavo/resources/inputs/__system__/
to make it visible to DaCHS

there is no need to keep epntap2.rd and epntap.rd separate, 
since only <mixinDef id="table"> and <procDef type="apply" id="populate">
need to be changed, and one RD file can have multiple definitions of these
however it may be more convinient to do so at the development stage - 
makes it easier to edit.

I don't understand why does epntap.rd have a column "accref"
<column name="accref" original="//products#products.accref"/>
This exposes my input data table. Is that really necessary? 
Also there is no property accref in specifications for either v1.0 or v2.0. 

Here we have all min/max pairs generated by <STREAM id="_minmax"> 
which is then fed via <FEED>, eg
			<FEED source="_minmax"
				basename="t_sampling_step"
				baseucd="time.interval" unit="s"
				baseutype="Epn.Time.Time_sampling_step"
				basedescr="Sampling time for measurements of dynamical
					phenomena"/>

The defalut values are provided by <mixinPar>, eg
		<mixinPar key="c1unit" description="Unit of the first spatial
			coordinate">deg</mixinPar>
			
I'm confused what does <property key="std">1</property> mean?

New row definitions are taken from this table:
https://voparis-confluence.obspm.fr/display/VES/EPN-TAP+V2.0+parameters

To add control flow to mixin best to use <code> tag...
which can be a child of either <processEarly> or <processLate>
which could be children of <mixinDef>.

<mixinDef> <processEarly code="..."> ... </processEarly> </mixinDef>
grants access to the structure of the mixin as "substrate"
mixin parameters as "mixinPars"
and to parse context as "context"

Using <processEarly> is probably preferable, as this is called on element fixup, rathar than resource fixup.
Consequently makes sense to place this at the end of <mixinDef>

Maybe something like
		<processEarly>
			<code>
			\c3unit='deg'
			</code>
		</processEarly> 
will work...

There is an example of <processLate> in obscore.rd:
		<processLate>
			<doc>
				Find all data items importing the table and furnish them
				with the scripts necessary to update the obscore view.
			</doc>
			<!-- see //products#hackProductsData for why this is a huge pain in
			the neck and how to get out of this. -->
			<code><![CDATA[
				if not substrate.onDisk:
					raise base.StructureError("Only onDisk tables can be obscore"
						" published, but %s is not."%substrate.id)

				rd = base.caches.getRD("//obscore")
				insertScript = rd.getById("addTableToObscoreSources")
				removeScript = rd.getById("removeTableFromObscoreSources")

				for dd in substrate.rd.iterDDs():
					addDependent = False
					for make in dd.makes:
						if make.table is substrate:
							make.scripts.append(insertScript)
							# the remove script needs to have the right parent
							make.feedObject("script", removeScript.copy(make))
							addDependent = True
					if addDependent:
						dd.dependents.append("//obscore#create")
			]]></code>
		</processLate>
	</STREAM>

this is the example refered to from products.rd of <processLate>:
<STREAM id="hackProductsData">
	<doc>
		This defines a processLate proc that hacks data instances
		building tables with products such that the products table
		is fed and the products instance columns are assigned to.
	</doc>
	<!-- This sucks.  We want a mechanism that lets us
		deposit events within the table definition; strutures referring
		to them could then replay them -->
	<processLate>
		<setup>
			<code>
				from gavo import rscdef
			</code>
		</setup>
		<code><![CDATA[
			if not substrate.onDisk:
				raise base.StructureError("Tables mixing in product must be"
					" onDisk, but %s is not"%substrate.id)
				# Now locate all DDs we are referenced in and...
			prodRD = base.caches.getRD("//products")
			for dd in substrate.rd.iterDDs():
				for td in dd:
					if td.id==substrate.id:
						# ...feed instructions to make the row table to it and...
						dd._makes.feedObject(dd, rscdef.Make(dd, 
							table=prodRD.getTableDefById("products"),
							rowmaker=prodRD.getById("productsMaker"),
							role="products"))
							# ...add some rules to ensure prodcut table cleanup,
						# and add mappings for the embedding table.
						for make in dd.makes:
							if make.table.id==substrate.id:
								# it was stupid to hack the host rowmaker from the mixin.
								# I need some exit strategy here.
								# Meanwhile: we're suppressing the hack if it'd fail
								# anyway.
								if "owner" in make.table.columns.nameIndex:
									base.feedTo(make.rowmaker,
										prodRD.getById("prodcolMaps").getEventSource(), context,
										True)

								base.feedTo(make,
									prodRD.getById("hostTableMakerItems").getEventSource(), 
									context, True)
		]]></code>
	</processLate>
</STREAM>
These are the only 2 instances of <processLate> in GAVO source code.

The definitions of <processEarly> and <processLate> are in 
gavo/rscdef/mixins.py
<processEarly> is used once - in ssap.rd to fill UCDs and Units:
gavo/resources/inputs/__system__/ssap.rd

	<mixinDef id="sdm-instance">
		<mixinPar key="spectralUnitOverride" description="Force unit of
			 the spectral column (don't use this)">__EMPTY__</mixinPar>
		<mixinPar key="spectralUCDOverride" description="Force UCD of the
			 spectral column (don't use this)">__EMPTY__</mixinPar>

		<processEarly>
			<setup>
				<code>
					from gavo import base
					from gavo import rscdef
					from gavo.protocols import sdm
				</code>
			</setup>
			<code>
				# copy over columns and params from the instance table as
				# params for us.
				ssapInstance = context.resolveId(mixinPars["ssaTable"])
				for col in ssapInstance.columns:
					atts = col.getAttributes()
					atts["utype"] = sdm.getSDM1UtypeForSSA(atts["utype"])
					atts["required"] = False
					substrate.feedObject("param", 
						base.makeStruct(rscdef.Param, parent_=substrate, **atts))
				for param in ssapInstance.params:
					newUtype = sdm.getSDM1UtypeForSSA(param.utype)
					substrate.feedObject("param", 
						param.change(utype=newUtype))

				specCol = substrate.getColumnByName("spectral")
				specCol.feed("ucd", "\spectralUCDOverride" or
					substrate.getParamByName("ssa_spectralucd").value)
				specCol.feed("unit", "\spectralUnitOverride" or
					substrate.getParamByName("ssa_spectralunit").value)

				fluxCol = substrate.getColumnByName("flux")
				fluxCol.feed("ucd",
					substrate.getParamByName("ssa_fluxucd").value)
				fluxCol.feed("unit",
					substrate.getParamByName("ssa_fluxunit").value)

				# set the SDM container meta if not already present
				if substrate.getMeta("utype", default=None) is None:
					substrate.setMeta("utype", "spec:Spectrum")
			</code>
		</processEarly>
	</mixinDef>
